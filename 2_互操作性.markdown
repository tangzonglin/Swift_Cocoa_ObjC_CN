互操作性
=======

与Objective-C API交互
--------------------

*互操作性*能让Swift与Objective-C双向互为接口，使你能够在一种语言中访问和使用另一种语言编写的代码。当你开始把Swift整合进开发工作流，先理解如何利用互操作性来改善、改进和增强编写Cocoa应用是个好主意。

关于互操作性的一个重要的方面是如何在你编写Swift代码时如何使用Objective-C的API。在导入Objective-C框架后，你可以用原生的Swift语法初始化类，并与之交互。

### 初始化

要在Swift中初始化一个Objective-C的类，你可以用Swift的语法调用它的某个构造方法。在Swift中，"init"前缀被去除，变成了指示构造方法的一个关键词。对于以"initWith"开头的`init`方法，"With"也被去掉了。构造方法的方法名中，去掉了"init"或"initWith"之后的第一个词被小写后，被作为第一个参数的参数名。剩下的方法名片段也分别作为相应的参数名。所有的方法名片段都被包含进括号中，在调用方法时都是必须的。

例如，在Objective-C中你会这么写：

``` objc
UITableView *myTableView = ［[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];
```

这个语句在Swift中，是这么写的：

``` swift
let myTableView : UITableView = UITableView(frame: CGRectZero, style: .Grouped)
```

你无需单独调用`alloc`；Swift会帮你正确处理的。需要注意的是，在调用Swift风格的构造方法时，没有出现"init"。

你可以在初始化的时候显示地声明对象的类型，你也可以省略类型声明。Swift的类型推断（Type Inference）功能可以正确的确定对象的类型。

``` swift
let myTextField = UITextField(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 40.0))
```

上述`UITableView`和`UITextField`对象有着你熟悉的与在Objective-C中的一样的功能。你可以像在Objective-C中一样使用它们，访问这些类的任何属性，调用任何方法。

为了一致性和简单起见，Objective-C中的工厂方法在Swift中被映射为快捷构造方法（Convenient Initializer）。这样映射可以让它们像构造方法一样，使用同样易于理解的，简明的语法被调用。例如，在Objective-C中，你像这样调用工厂方法：

``` objc
UIColor *color = [UIColor colorWithRed: 0.5 green: 0.0 blue: 0.5 alpha: 1.0];
```

在Swift中，你可以这样调用：

``` swift
let color = UIColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0)
```

### 可失败构造方法

在Objective-C中，构造方法直接返回它们初始化的对象。要在初始化失败的时候告知调用者，Objective-C的构造方法会返回`nil`。在Swift中，这种模式成为一种语言特性，称为“*可失败构造方法（failable initializer）*”。

iOS和OS X的系统框架中的很多Objective-C构造方法已经被修改为可以指示初始化是否会失败。你也可以在你自己的Objective-C类中使用*可空性标记（nullability annotions）*指示构造方法是否会初始化失败，详见[空值和可选类型](#空值和可选类型)。根据是否会初始化失败，Objective-C的构造方法会被导入为`init(...)`--如果不会初始化失败，或者`init?(...)`--如果可能会初始化失败。否则，Objective-C的构造方法会被导入为`init!(...)`。

例如，`UIImage(contentOfFile:)`构造方法在初始化`UIImage`对象的时候，在给定的路径下图片文件不存在时，就会初始化失败。你可以使用可选类型绑定（Optional Binding）来提取可失败构造方法在初始化成功后的结果。

``` swift
if let image = UIImage(contentOfFile: "MyImage.png") {
	// 图片载入成功
} else {
	// 无法载入图片
}
```

### 访问属性

Objective-C中，使用`@property`语法来声明属性，在Swift中通过如下方法被导入：

- 包含空值指示参数（`nonnull`，`nullable`和`null_resettable`）的属性，在导入为Swift属性的时候会导入为对应的可选类型或非可选类型，详见[空值和可选类型](#空值和可选类型)。
- 包含`readonly`(只读)参数的属性，在Swift中被导入为只包含取值方法（gette）(`{getter}`)的计算属性（computed property）。
- 包含`weak`（弱）参数的属性，在导入为Swift属性时也会使用`weak`关键词标注（`weak var`）。
- 包含除`weak`外的其他所属关系参数（也就是`assign`，`copy`，`strong`或`unsafe_unretained`）的属性在导入为Swift属性的时候，会被正确的存储。
- 包含原子性参数（`atomic`和`nonatomic`）的属性在Swift中被忽略。所有的Swift属性都是`nonatomic`的。
- 属性的访问方法（accessor）参数（`getter=`和`setter=`）在Swift中被忽略。

在Swift中访问Objective-C对象的属性使用点语法（dot syntax），属性名保持不变，后面无需括号。

例如，你可以用如下代码为`UITextField`对象设置`textColor`和`text`属性：

``` swift
myTextField.textColor = UIColor.darkGrayColor()
myTextField.text = "Hello world"
```

> **提示**
>
> `darkGrayColor()`的后面是包含括号的，因为`darkGrayColor()`是`UIColor`类的一个方法，不是一个属性。

Objective-C中，不包含参数，但是有返回值的方法可以像Objective-C属性一样用点语法调用。但是这些方法是作为实例方法导入Swift的，只有使用`@property`声明的Objective-C属性才会被导入为Swift属性。方法的导入和调用在[方法的使用](#方法的使用)部分介绍。

### 方法的使用

从Swift中调用Objective-C方法时，使用点语法。

当Objective-C方法导入Swift之后，Objective-C方法名（selector）的第一部分变成Swift的方法名，出现在括号外面。第一个参数紧随开括号出现，是没有参数名的。方法名的其他部分分别作为对应命名参数出现在括号中。在调用时，所有的参数都是必须的。

例如，在Objective-C中，你会这样编写代码：

``` objc
[myTableView insertSubview: mySubview atIndexPath: 2];
```

在Swift中，你这么写：

``` swift
myTableView.insertSubview(mySubView, atIndexPath: 2)
```

如果你调用的方法没有参数，你依然需要在最后包含一个空括号。

``` swift
myTableView.layoutIfNeeded()
```

### id的兼容性

Swift包含了一种称为`AnyObject`的协议类型（protocol type），可以代表任何类型的对象，就像Objective-C中的`id`一样。`AnyObject`协议使你能够在编写类型安全的Swift代码的同时，又不失去使用未指定类型的对象的弹性。因为Swift的AnyObject协议提供了额外的安全性，Swift会将`id`导入为`AnyObject`。

例如，像`id`一样，你可以为类型为`AnyObject`的常量或变量赋任何类型的值。

``` swift
var myObject : AnyObject = UITableViewCell()
myObject = NSDate()
```

你也可以无需强制类型转化，就能调用任何Objective-C方法，访问任何属性。包括使用`@objc`注解（attribute）的Objective-C的兼容方法。

``` swift
let futureDate = myObject.dateByAddingTimeInterval(10)
let timeSinceNow = myObject.timeIntervalSinceNow
```

不过，声明为`AnyObject`的对象的类型要到运行时才被确定，因此可能会导致你不经意地编写了不安全的代码。和Objective-C中一样，如果你对一个`AnyObject`类型的对象调用了一个不存在的方法或访问了不存在的属性，会导致一个运行时错误。例如，下面这行代码能够顺利编译通过，但是在运行时会产生不识别的方法（unrecognized selector）错误：

``` swift
myObject.charactorAtIndex(5)
// 程序崩溃，myObject不能执行这个方法
```

你可以利用Swift的可选类型来消除这类常见的Objective-C错误。当你对`AnyObject`对象调用Objective-C方法的时候，方法调用的行为实际上于隐式解包可选类型（implicit unwrapped optionals）差不多。你可以用像在调用协议中的可选方法时使用的可选调用链（Optional Chaining）一样，来对`AnyObject`对象可选地触发一个方法。

> **提示**
>
> 访问AnyObject类型的对象的属性，总是返回可选类型值。

例如，在下面列出的代码中，第一行和第二行没有被执行，因为`count`属性和`characterAtIndex:`方法在`NSDate`对象中不存在。`myCount`常量被推断为可选`Int`类型，然后被赋值为`nil`。你也可以使用`if`-`let`语句来有条件地提取对象可能无法响应的方法的执行结果，就像第三行代码展示的那样。

``` swift
let myCount = myObject.count
let myChar = myObject.characterAtIndex?(5)
if let fifthCharacter = myObject.characterAtIndex?(5) {
	print("Found \(fifthCharacter) at Index 5")
}
```

当你处理底层类型已知或者可以被合理推断出来的`AnyObject`对象的时候，我们通常会把对象向下转换为某个更加特定的类型。但是因为`AnyObject`可能代表任何类型的对象，类型转换并不能保证成功。你可以使用条件类型转换操作符（`as?`）来进行转换操作，用它将返回一个你尝试转换为的类型的可选类型：

``` swift
let userDefaults = NSUserDefaults.standardUserDefaults()
let lastRefreshDate : AnyObject? = userDefaults.objectForKey("LastRefreshDate")
if let date = lastRefreshDate as? Date {
	print("\(date.timeIntervalSinceReferenceDate)")
}
```

另外，你也可以使用强制向下转换操作符（`as!`），用它将返回一个你要转换成的类型的非可选的值：

``` swift
let myDate = lastReferenceDate as! NSDate
let timeInterval = myDate.timeIntervalSinceReferenceDate
```

不过，如果强制类型转换失败了，将会触发一个运行时错误：

``` swift
let myDate = lastReferenceDate as! NSString // 错误
```

正因为如此，你只应该在你可以确信`AnyObject`对象的底层类型时，才使用强制类型转换。

### 空值和可选类型

（译者注：nullability这里翻译为空值，主要是为了不发明大家看不懂的新词。nullability的直译的话，意为“可否为空值的一种能力”。后文中nullbility将不会使用直译，我会根据上下文环境尽量避免晦涩，多用意译。）

在Objective-C中，你使用原生的指针来操作可能为`NULL`(在Objective-C中被称为`nil`)的引用。在Swift中，所有的值--包括结构体和对象引用--总是为非空的。取而代之，你需要将可能为空的值封装到一个可选类型（optional type）中。当你需要指示值为空的时候，你可以使用nil。要了解更多关于可选类型的信息，你可以参阅*Swift编程语言（Swift 2版）*的可选类型章节。

Objective-C可以使用空值标记（nullability annotation）来标示参数、属性或返回值能否包含`NULL`或`nil`。单独的类型声明可以使用`_Nullable`和`_Nonnull`标记，单独的属性声明可以使用`nullable`，`nonnull`和`null_resettable`标记，或者你也可以使用`NS_ASSUME_NONNULL_BEGIN`和`NS_ASSUME_NONNULL_END`宏来标记一整块区域接受和返回非空值。如果类型没有空值标记信息，Swift就无法区分可选和非可选的引用了，它们将被作为隐式解包可选类型被导入。

- 无论是用`_Nonnull`标记或者包围在非空宏被声明为不为空的类型，作为非可选类型导入Swift。
- 使用`_Nullable`标记为可为空的类型，作为可选类型导入Swift。
- 没有使用空值标记的类型，作为隐式解包可选类型导入Swift。

例如，来看看的这段Objective-C声明：

``` objc
@property (nullable) id nullableProperty;
@property (nonnull) id nonNullProperty;
@property id unannotatedProperty;

#NSASSUME_NONNULL_BEGIN
- (id)returnsNonNullValue;
- (void)takesNonNullParameter:(id)value;
#NSASSUME_NONNULL_END

- (nullable id) returnsNullableValue;
- (void) takesNullableParameter:(nullable id)value;

- (id)returnsUnannotatedValue;
- (void)takesUnannotatedParameter:(id)value;
```

它们是这样被导入Swift的：

``` swift
var nullableProperty : AnyObject?
var nonNullProperty : AnyObject
var unannotatedProperty : AnyObject!

func returnsNonNullValue() -> AnyObject
func takesNonNullParameter(value: AnyObject)

func returnsNullableValue() -> AnyObject?
func takesNullableParameter(value: AnyObject?)

func returnsUnannotatedValue() -> AnyObject!
func takesUnannotatedParameter(value: AnyObject!)
```

### 轻量级泛型

Objective-C中，使用轻量级泛型进行参数化的声明的`NSArray`，``NSSet`和`NSDictionary`类型，在导入Swift的时候，参数的类型信息会被保留。

例如，下面的这段Objective-C的属性声明：

``` objc
@property NSArray<NSDate *> *dates;
@property NSSet<NSString *> *words;
@property NSDictionary<NSURL *, NSData *> *cachedData;
```

是这样导入Swift的：

``` swift
var dates : [NSDate]
var words : Set<String>
var cachedData : [NSURL : NSData]
```

> **提示**
>
> 除了这些Foundation框架中的集合类之外，Objective-C的轻量级泛型会被Swift忽略。其他任何使用了轻量级泛型的类型在导入Swift的时候，都会被去参数化。

### 扩展

Swift的扩展(Extension)与Objective-C的扩展（Category）类似。*扩展*可以为已有的类、结构体和枚举，甚至是那些在Objective-C中定义的类型，增加新的行为。无论是系统框架中定义的类，还是你自己的自定义类型，你都可以为它们定义扩展。你只需导入适当的模块，用类、结构体或枚举的名字来使用它们，就像在Objective-C中一样。

比如，你可以像下面这样扩展`UIBezierPath`类，利用边长和起始点来创建一个简单的等边三角形贝塞尔曲线。

``` swift
extension UIBezierPath {
	convenience init(triangleSideLength: CGFloat, origin: CGPoint) {
		self.init()
		let squareRoot = CGFloat(sqrt(3.0))
		let altitude = (squareRoot * triangleSideLegth) / 2
		moveToPoint(origin)
		addLineToPoint(CGPoint(x: origin.x + triangleSideLength, y: origin,y))
		addLineToPoint(CGPoint(x: origin.x + triangleSideLength / 2, y: origin.y + altitude))
		closePath()
	}
}
```

你也可以使用扩展增加属性（包括类属性和静态属性）。不过这些属性必须为计算属性；扩展无法为类、结构体或枚举增加带存储的属性。

下面这个扩展的例子展示了如何为`CGRect`结构体增加一个计算属性`area`：

``` swift
extension CGRect {
	var area : CGFloat {
		return width * height
	}
}

let rect = CGRect(x: 0.0, y: 0.0, width: 10.0, height: 50.0)
let area = rect.area
```

你还可以使用扩展来增加协议支持，而无需创建子类。如果协议是在Swift中定义的，那么不管结构体和枚举是在Swift还是在Objective-C中定义的，你都可以通过扩展让它们支持该协议。

你不能使用扩展来覆盖Objective-C类型的已有的方法或属性。

### 闭包

用`@convention(block)`注解标记的Objective-C的块（block）在导入为Swift闭包时，使用Objective-C的调用规则。例如，下面的这个Objective-C的块变量：

``` objc
void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) {
	// ...
}
```

导入Swift后，它是这样的：

``` swift
let completionBlock: (NSData, NSError) -> Void = { (data, error) in
	// ...
}
```

Swift的闭包与Objective-C的块是兼容的，你可以为接受块参数的Objective-C方法传一个Swift的闭包。如果Swift的闭包和函数有相同的类型签名，你甚至可以直接传一个Swift函数名。

闭包与块有着相似的值捕获语义（capture semantics），但是有一个关键的地方不一样：变量是可以被更改的，而不是被复制的。换句话说，Objective-C中，需要使用`__block`标记的变量的行为，在Swift中是默认行为。

#### 捕获self的时候避免强引用循环

在Objective-C中，如果你需要在块中捕获`self`，你需要考量一下内存管理机制。

块会对捕获的对象，包括`self`，保持强引用。如果`self`也对块保持了强引用，比如复制属性，这样就会造成强引用循环。要避免这个问题，你可以让块捕获`self`的一个弱引用：

``` objc
__weak typeof(self) weakSelf = self;
self.block = ^{
	__strong typeof(self) strongSelf = weakSelf;
	[strongSelf doSomething];
}
```

与Objective-C的块一样，Swift也会对捕获的任何对象，包括`self`，保持一个强引用。要避免强引用循环，你需要在闭包的捕获列表中，把`self`标记为`unowned`：

``` swift
self.closure = ^{ [unowned self] in
	self.doSomething()
}
```

要了解更多信息，请参考*Swift编程语言（Swift 2版）*的“解决闭包的强引用循环”章节。

### 对象比较

在比较两个对象的时候，Swift中有两种不同的比较方法。第一种，是*相等*（`==`），比较两个对象的内容。第二种，是*相同（`===`）*，比较常量或变量指向的对象是否为同一个对象实例。

在Swift中，Swift和Objective-C的对象通常使用`==`和`===`操作符进行比较。Swift为派生自`NSObject`类的对象提供了一个默认的`==`操作符实现。这个操作符的视线中，Swift会触发`NSObject`类中定义的的`isEqual:`方法。`NSObject`类只会比较两者是否为同一个对象，因此，如果你的类派生自`NSObject`，你需要实现你自己的`isEqual:`方法。因为你向Objective-C的API传入Swift对象（包括那些不是派生自`NSObject`的对象），因此，如果你希望Swift类在Objective-C的API中也是比较内容，而不是比较是否相同，你也应该为那些类实现`isEqual:`方法。

作为显现类的相等性的一部分，根据对相比较的规则，请确保实现`hash`属性。另外，如果你希望你的类可以用作字典的键，请遵守`Hashable`协议，并实现`hashValue`属性。

### Swift类型的兼容性

当你创建了一个派生自Objective-C类的Swift类，这个类以及它的与Objective-C兼容的成员--属性、方法、下标（subscript，译者注：也就是从一组值中用索引取值的方法）以及构造方法等--会自动对Objective-C可用。在某些情况下，你可能需要精细控制如何将Swift API暴露给Objective-C。如果你的Swift类并不是派生自Objective-C的类，或者你希望修改暴露给Objective-C代码接口的方法名，你可以在Swift类中使用`@objc`注解。如果你使用了类似“键-值观察（key-value observing）”这样动态替换方法实现的的API，你也可以使用`dynamic`修饰符来标记这些通过Objective-C运行时被动态设置的类成员。

#### 在Swift中对Objective-C暴露接口

当你定义了一个派生自`NSObject`或其他Objective-C类的Swift类，这个类会自动与Objective-C兼容。如果你的Swift类并非派生自Objective-C的类，但是你希望你可以在Objective-C代码中访问这个类的API，你可以使用在下面介绍的`@objc`注解。

`@objc`注解使你的Swift API在Objective-C以及Objective-C的运行时环境中可用。换句话说，要在Objective-C代码中使用Swift代码，你要在Swift的方法、属性、下标、构造方法、类、协议、或枚举的前面使用`@objc`注解。

> **提示**
>
> 嵌套的类型定义是不能用`@objc`注解标记的。
>
> 只有使用基本整数类型，如`Int`作为其原始值的Swift枚举，才能使用`@objc`注解。

如果你的类派生自Objective-C类，编译器会自动为你插入注解。编译器也会为标记有`@objc`注解的类的所有成员加上注解。当你使用`@IBOutlet`，`@IBAction`，或`@NSManaged`注解时，也会自动加上`@objc`注解。

需要注意的是，只有派生自`NSObject`的类才能用`@objc`整体标记（编译器会自动标记），但是，如果类并不是派生自`NSObject`，你依然可以用`@objc`标记类内的API。这在调用接受选择器（selector）的Objective-C API，来实现像目标-动作（target-action）设计模式时特别有用，比如`NSTimer`或`UIButton`。

> **提示**
>
> 编译器不会为使用`private`访问级别修饰符的声明自动添加`@objc`注解。

当你在Objective-C中使用Swift API的时候，编译器通常时直接翻译。比如，这个Swift的API `func playSong(name: String)`，导入Objective-C的时候是这样的`- (void)playSong:(NSString *)name`。不过有一个例外：当你在Objective-C中使用Swift的构造函数时，编译器会在方法名前面加上"initWith"，并把第一个参数名首字母大写。例如这个Swift构造器：`init(songName: String, artist: String)`在Objective-C中导入为`- (instanceType)initWithSongName:(NSString *)songName artist:(NSString *)artist`。

Swift还提供了一个`@objc`注解的变体，用来指定暴露给Objective-C的符号名。例如，如果Swift类包含Objective-C不支持的字符，你可以指定一个Objective-C可用的备用名。如果你是为Swift方法指定备用名，请使用Objective-C的选择器语法。记得在选择的各部分之间加上冒号`:`。

``` swift
@objc(Squirrel)
class 松鼠 : NSObject {
	@objc(initWithName:)
	init(名字: String) {
		// ...
	}

	@objc(hideNuts:inTree:)
	func 收藏(几: Int, 个坚果到大树 大树: 树) {
		// ...
	}
}
```

当你对Swift的类使用`@objc(`*name*`)`注解的时候，这个类会在Objective-C中可用，并且不在任何名字空间内。因此，这个注解在你迁移一个可以存档（archivable）的Objective-C类到Swift的时候也很有用。因为可以存档的对象会保存它们的类名到存档文件（archive）中，你应该使用`@objc(`*name*`)`注解来指定与Objective-C类一样的名字，这样，旧的存档文件才能被你的新Swift类解包（unarchive）。

> **提示**
>
> 相对的，Swift也可以用`@nonobjc`注解，让Swift中的声明在Objective-C中不可用。你可以用这个方法来解决桥接方法（bridging methods）的循环引用，这样就可以覆盖用`@objc`注解标记的类中的方法。如果一个Objective-C的方法被Swift的方法覆盖，但该方法无法在Objective-C中表示，例如，通过指定一个参数为变量，拿个方法必须标记为`@nonobjc`。（译者注：__FIXME__此处意思不太明确）

#### 需要动态分配

尽管`@objc`注解能把你的Swift API暴露给Objective-C运行时环境，但是它无法确保属性、方法、下标或构造器的动态分配（dynamic dispatch）。Swift编译器可能依然会去虚化（devirtualize）或内嵌（inline）访问成员，绕过Objective-C环境，优化你的代码的性能。当你用`dynamic`修饰符标记成员的声明，访问这个成员的时候，能保证它总是动态分配的。因为用`dynamic`修饰符标记的声明总是通过Objective-C运行时环境动态分配，它们被隐性地标记了`@objc`注解。

需要动态分配的场景很少。不过如果你知道某个API的实现会被运行时替换，那么你就必须使用`dynamic`修饰符。例如，你可以使用Objective-C运行时环境的`method_exchangeImplementations`方法在程序运行时替换到一个方法的实现。如果Swift编译器内嵌了方法的实现，或者把它的访问去虚化了，那么新的实现将不被使用。

### Objective-C的方法选择器

Objective-C的方法选择器是一种指向Objective-C方法名的类型。在Swift中，Objective-C的方法选择器用`Selector`结构体表示。你可以用一个字符串来构造一个方法选择器，例如`let mySelector: Selector = "tappedButton:"`。因为字符串可以自动转换为方法选择器，所以你可以给所有接受方法选择器参数的方法传入一个字符串。

``` swift
import UIKit

class MyViewController : UIViewController {
	let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))

	override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) {
		super.init(nibName: nibNameOrNil, bundle: nilBundleOrNil)
		myButton.addTarget(self, action: "tappedButton:", forControlEvents: .TouchUpInside)
	}

	func tappedButton(sender:UIButton) {
		print("tapped button")
	}

	required init?(coder:NSCoder) {
		super.init(coder: coder)
	}
}
```

如果你的Swift类继承自Objective-C类，类中的所有的方法和属性都可以用作Objective-C的方法选择器。反之，如果你的Swift类并没有继承自Objective-C类，那么你需要使用`@objc`注解标注你想用作方法选择器的成员，就像在[Swift类型的兼容性](#Swift类型的兼容性)中描述的那样。

#### 用performSelector来发送消息

（译者注：Objective-C的发送消息，在其他语言中叫做方法调用，两者有所区别，但是基本作用相同。）

你可以使用`performSelctor(_:)`及其变体向Objective-C兼容的对象发送消息。

`performSelector` API可以向某个线程或在一段时间的延迟后发送的消息，是没有返回值的。同步执行的`performSelector` API返回一个隐式解包的非托管的可选类型实例（`Unmanaged<AnyObject>!`），因为执行方法选择器得到返回值的类型、所属关系在编译时无法知晓。你可以阅读[非托管对象](#非托管对象)章节了解更多信息。

``` swift
let string: NSString = "Hello, Cocoa!"
let selector: Selector = "lowercaseString"
if let result = string.performSelector(selector) {
	print(result.takeUnretainedValue())
}
// 打印出 "hello, cocoa!"
```

向对象发送一个无法识别的方法选择器，会导致接收者去调用`doesNotRecognizeSelector(_:)`，这个方法默认引发一个`NSInvalidArgumentException`异常。

``` swift
let array: NSArray = ["delta", "alpha", "zulu"]
let invalidSelecto: Selector = "invalid"
array.performSelector(invalidSelector) // 引发一个异常
```

在Objective-C运行时向对象直接发送消息在本质上是不安全的，因为编译器无法对发送消息得到的结果作保证，甚至无法保证对象可以接收某个消息。因此，通常是不鼓励使用`performSelector` API的，除非你的代码对Objective-C运行时提供的动态方法解析有特殊需求。否则，把一个类型的对象转换成`AnyObject`，然后使用可选调用链来调用方法会安全很多。详见[id的兼容性](#id的兼容性)。

编写具备Objective-C行为的Swift类
------------------------------

互操作性是你能够定义具备Objective-C行为的Swift类。你可以在编写Swift类的时候继承Objective-C的类，接受Objective-C的协议，并利用其他Objective-C的功能。这意味着你可以创建基于你熟悉的、有着明确Objective-C行为的类创建子类，同时，你可以使用Swift的现代、强大的语言特征来增强它。

### 继承Objective-C的类

在Swift中，你可以定义Objective-C类的子类。要创建一个继承自Objective-C类的Swift类，你可以在Swift的类名后架上冒号（`:`），再加上Objective-C类的名字。

``` swift
import UIKit
class MySwiftViewController : UIViewController {
	// 定义这个类
}
```

你可以获得用Objective-C定义的超类的所有功能。如果你要为超类中的同名方法提供你自己的实现，你需要使用`override`关键字。

#### NSCoding

`NSCoding`协议要求符合改协议的类型实现`init(coder:)`构造方法。直接接受`NSCoding`协议的类必须实现这个方法，该类的子类如果有一个以上自定义构造方法、或包含没有初始值的属性，那么它也必须接受`NSCoding`协议。Xcode提供了下面这个自动修正（fix-it）功能，提供了一个默认实现：

``` swift
required init(coder aDecoder: NSCoder) {
	fatalError("init(coder:) has not been implemented")
}
```

对于从StoryBoard中加载的对象，或者用`NSUserDefaults`或`NSKeyedArchiver`从磁盘上解包的对象，你必须为这个构造函数提供一个完整的实现。不过，你可能不需要为那些无法或不会通过这种途径初始化的类型实现这个构造方法。
