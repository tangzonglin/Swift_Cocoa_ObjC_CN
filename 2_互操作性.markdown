互操作性
=======

与Objective-C API交互
--------------------

*互操作性*能让Swift与Objective-C双向互为接口，使你能够在一种语言中访问和使用另一种语言编写的代码。当你开始把Swift整合进开发工作流，先理解如何利用互操作性来改善、改进和增强编写Cocoa应用是个好主意。

关于互操作性的一个重要的方面是如何在你编写Swift代码时如何使用Objective-C的API。在导入Objective-C框架后，你可以用原生的Swift语法初始化类，并与之交互。

### 初始化

要在Swift中初始化一个Objective-C的类，你可以用Swift的语法调用它的某个构造方法。

在Objective-C中，构造方法以`init`开头，如果构造方法接受一个或多个参数则是以`initWith:`开头。当一个Objective-C的构造方法被导入Swift中的时候，`init`前缀变为`init`关键词，用来指示这个方法是Swift的构造方法。如果构造方法需要接受参数，那么`With`会被去掉，方法选择器（selector）剩下的部分会分别作为构造方法的命名参数。

比如下面的Objective-C构造方法声明：

``` objc
- (instancetype)init;
- (instancetype)initWithFrame:(CGRect)frame
						style:(UITableViewStyle)style;
```

下面是等效的Swift构造方法声明：

``` swift
init() { /* ... */ }
init(frame: CGRect, style: UITableViewStyle) { /* ... */ }
```

Objective-C和Swift的语法的差别在初始化对象的时候就很明显了。

在Objective-C中，你这么写：

``` objc
UITableView *myTableView = ［[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];
```

在Swift中，是这么写的：

``` swift
let myTableView : UITableView = UITableView(frame: CGRectZero, style: .Grouped)
```

注意到，你无需单独调用`alloc`；Swift会帮你正确处理的。需要注意的是，在调用Swift风格的构造方法时，没有出现"init"。

你可以在初始化的时候显示地声明对象的类型，你也可以省略类型声明。Swift的类型推断（Type Inference）功能可以正确的确定对象的类型。

``` swift
let myTextField = UITextField(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 40.0))
```

上述`UITableView`和`UITextField`对象有着你熟悉的与在Objective-C中的一样的功能。你可以像在Objective-C中一样使用它们，访问这些类的任何属性，调用任何方法。

#### 类的工厂方法和快捷构造方法

为了一致性和简单起见，Objective-C中的工厂方法在Swift中被映射为快捷构造方法（Convenient Initializer）。这样映射可以让它们像构造方法一样，使用同样易于理解的，简明的语法被调用。例如，在Objective-C中，你像这样调用工厂方法：

``` objc
UIColor *color = [UIColor colorWithRed: 0.5 green: 0.0 blue: 0.5 alpha: 1.0];
```

在Swift中，你可以这样调用：

``` swift
let color = UIColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0)
```

### 可失败构造方法

在Objective-C中，构造方法直接返回它们初始化的对象。要在初始化失败的时候告知调用者，Objective-C的构造方法会返回`nil`。在Swift中，这种模式成为一种语言特性，称为“*可失败构造方法（failable initializer）*”。

iOS和OS X的系统框架中的很多Objective-C构造方法已经被修改为可以指示初始化是否会失败。你也可以在你自己的Objective-C类中使用*可空性标记（nullability annotions）*指示构造方法是否会初始化失败，详见[空值和可选类型](#空值和可选类型)。根据是否会初始化失败，Objective-C的构造方法会被导入为`init(...)`--如果不会初始化失败，或者`init?(...)`--如果可能会初始化失败。否则，Objective-C的构造方法会被导入为`init!(...)`。

例如，`UIImage(contentOfFile:)`构造方法在初始化`UIImage`对象的时候，在给定的路径下图片文件不存在时，就会初始化失败。你可以使用可选类型绑定（Optional Binding）来提取可失败构造方法在初始化成功后的结果。

``` swift
if let image = UIImage(contentOfFile: "MyImage.png") {
	// 图片载入成功
} else {
	// 无法载入图片
}
```

### 访问属性

Objective-C中，使用`@property`语法来声明属性，在Swift中通过如下方法被导入：

- 包含空值指示参数（`nonnull`，`nullable`和`null_resettable`）的属性，在导入为Swift属性的时候会导入为对应的可选类型或非可选类型，详见[空值和可选类型](#空值和可选类型)。
- 包含`readonly`(只读)参数的属性，在Swift中被导入为只包含取值方法（gette）(`{getter}`)的计算属性（computed property）。
- 包含`weak`（弱）参数的属性，在导入为Swift属性时也会使用`weak`关键词标注（`weak var`）。
- 包含除`weak`外的其他所属关系参数（也就是`assign`，`copy`，`strong`或`unsafe_unretained`）的属性在导入为Swift属性的时候，会被正确的存储。
- 包含原子性参数（`atomic`和`nonatomic`）的属性在Swift中被忽略。所有的Swift属性都是`nonatomic`的。
- 属性的访问方法（accessor）参数（`getter=`和`setter=`）在Swift中被忽略。

在Swift中访问Objective-C对象的属性使用点语法（dot syntax），属性名保持不变，后面无需括号。

例如，你可以用如下代码为`UITextField`对象设置`textColor`和`text`属性：

``` swift
myTextField.textColor = UIColor.darkGrayColor()
myTextField.text = "Hello world"
```

> **提示**
>
> `darkGrayColor()`的后面是包含括号的，因为`darkGrayColor()`是`UIColor`类的一个方法，不是一个属性。

Objective-C中，不包含参数，但是有返回值的方法可以像Objective-C属性一样用点语法调用。但是这些方法是作为实例方法导入Swift的，只有使用`@property`声明的Objective-C属性才会被导入为Swift属性。方法的导入和调用在[方法的使用](#方法的使用)部分介绍。

### 方法的使用

从Swift中调用Objective-C方法时，使用点语法。

当Objective-C方法导入Swift之后，Objective-C方法名（selector）的第一部分变成Swift的方法名，出现在括号外面。第一个参数紧随开括号出现，是没有参数名的。方法名的其他部分分别作为对应命名参数出现在括号中。在调用时，所有的参数都是必须的。

例如，在Objective-C中，你会这样编写代码：

``` objc
[myTableView insertSubview: mySubview atIndexPath: 2];
```

在Swift中，你这么写：

``` swift
myTableView.insertSubview(mySubView, atIndexPath: 2)
```

如果你调用的方法没有参数，你依然需要在最后包含一个空括号。

``` swift
myTableView.layoutIfNeeded()
```

### id的兼容性

Swift有一种`AnyObject`类型，用来代表某个对象。这种类型和Objective-C中的`id`类型很类似。Swift会把`id`导入为`AnyObject`，使你能够在编写类型安全的Swift代码的同时，又不失去使用未指定类型的对象的弹性。因为Swift的AnyObject协议提供了额外的安全性。

例如，像`id`一样，你可以为类型为`AnyObject`的常量或变量赋任何类型的值。你甚至可以在给变量重新赋值的时候，使用另一种类型的对象。

``` swift
var myObject : AnyObject = UITableViewCell()
myObject = NSDate()
```

你也可以无需强制类型转化，就能调用任何Objective-C方法，访问任何属性。包括使用`@objc`注解（attribute）的Objective-C的兼容方法。

``` swift
let futureDate = myObject.dateByAddingTimeInterval(10)
let timeSinceNow = myObject.timeIntervalSinceNow
```

#### 无法识别的方法选择器和可选调用链

因为声明为`AnyObject`的对象的类型要到运行时才被确定，因此可能会导致你不经意地编写了不安全的代码。不论是在Swift中还是在Objective-C中，试图调用一个不存在的方法，会引发“无法识别的方法选择器”（unrecognized selector）错误。

例如，下面这行代码能够顺利编译通过，但是在运行时会产生不识别的方法（unrecognized selector）错误：

``` swift
myObject.charactorAtIndex(5)
// 程序崩溃，myObject不能执行这个方法
```

Swift使用可选类型来应对这种不安全的行为。当你对`AnyObject`类型的值调用方法的时候，方法调用的行为与隐式解包可选类型（implicit unwrapped optionals）差不多。你可以用像在调用协议中的可选方法时使用的可选调用链（Optional Chaining）一样，来对`AnyObject`对象可选地触发一个方法。

> **提示**
>
> 访问AnyObject类型的对象的属性，总是返回可选类型值。如果属性本来就是返回一个可选类型，那么它的返回值就回编程一个双重包装的可选类型（doubly-wrapped optional type），例如`AnyObject?!`。

例如，在下面列出的代码中，第一行和第二行没有被执行，因为`count`属性和`characterAtIndex:`方法在`NSDate`对象中不存在。`myCount`常量被推断为可选`Int`类型，然后被赋值为`nil`。你也可以使用`if`-`let`语句来有条件地提取对象可能无法响应的方法的执行结果，就像第三行代码展示的那样。

``` swift
// myObject是AnyObject类型，包含了一个NSDate值
let myCount = myObject.count
// myCount是Int?类型，值为nil
let myChar = myObject.characterAtIndex?(5)
// myChar是unichar?类型，值为nil
if let fifthCharacter = myObject.characterAtIndex?(5) {
	print("Found \(fifthCharacter) at Index 5")
}
// 条件分支没有被执行
```

> **提示**
>
> 尽管Swift在对类型为`AnyObject`的值调用方法时，并不会要求强制解包，不过这是一种安全应对未知行为的途径之一。

#### 类型向下强制转换

当你处理底层类型已知或者可以被合理推断出来的`AnyObject`对象的时候，我们通常会把对象向下转换为某个更加特定的类型。但是因为`AnyObject`可能代表任何类型的对象，类型转换并不能保证成功。

你可以使用条件类型转换操作符（`as?`）来进行转换操作，用它将返回一个你尝试转换为的类型的可选类型：

``` swift
let userDefaults = NSUserDefaults.standardUserDefaults()
let lastRefreshDate : AnyObject? = userDefaults.objectForKey("LastRefreshDate")
if let date = lastRefreshDate as? Date {
	print("\(date.timeIntervalSinceReferenceDate)")
}
```

如果你确知对象的类型，你也可以使用强制向下转换操作符（`as!`）。

``` swift
let myDate = lastReferenceDate as! NSDate
let timeInterval = myDate.timeIntervalSinceReferenceDate
```

不过，如果强制类型转换失败了，将会触发一个运行时错误：

``` swift
let myDate = lastReferenceDate as! NSString // 错误
```

### 空值和可选类型

（译者注：nullability这里翻译为空值，主要是为了不发明大家看不懂的新词。nullability的直译的话，意为“可否为空值的一种能力”。后文中nullbility将不会使用直译，我会根据上下文环境尽量避免晦涩，多用意译。）

在Objective-C中，你使用原生的指针来操作可能为`NULL`(在Objective-C中被称为`nil`)的引用。在Swift中，所有的值--包括结构体和对象引用--总是为非空的。取而代之，你需要将可能为空的值封装到一个可选类型（optional type）中。当你需要指示值为空的时候，你可以使用nil。要了解更多关于可选类型的信息，你可以参阅*Swift编程语言（Swift 2版）*的可选类型章节。

Objective-C可以使用空值标记（nullability annotation）来标示参数、属性或返回值能否包含`NULL`或`nil`。单独的类型声明可以使用`_Nullable`和`_Nonnull`标记，单独的属性声明可以使用`nullable`，`nonnull`和`null_resettable`标记，或者你也可以使用`NS_ASSUME_NONNULL_BEGIN`和`NS_ASSUME_NONNULL_END`宏来标记一整块区域接受和返回非空值。如果类型没有空值标记信息，Swift就无法区分可选和非可选的引用了，它们将被作为隐式解包可选类型被导入。

- 无论是用`_Nonnull`标记或者包围在非空宏被声明为不为空的类型，作为非可选类型导入Swift。
- 使用`_Nullable`标记为可为空的类型，作为可选类型导入Swift。
- 没有使用空值标记的类型，作为隐式解包可选类型导入Swift。

例如，来看看的这段Objective-C声明：

``` objc
@property (nullable) id nullableProperty;
@property (nonnull) id nonNullProperty;
@property id unannotatedProperty;

#NSASSUME_NONNULL_BEGIN
- (id)returnsNonNullValue;
- (void)takesNonNullParameter:(id)value;
#NSASSUME_NONNULL_END

- (nullable id) returnsNullableValue;
- (void) takesNullableParameter:(nullable id)value;

- (id)returnsUnannotatedValue;
- (void)takesUnannotatedParameter:(id)value;
```

它们是这样被导入Swift的：

``` swift
var nullableProperty : AnyObject?
var nonNullProperty : AnyObject
var unannotatedProperty : AnyObject!

func returnsNonNullValue() -> AnyObject
func takesNonNullParameter(value: AnyObject)

func returnsNullableValue() -> AnyObject?
func takesNullableParameter(value: AnyObject?)

func returnsUnannotatedValue() -> AnyObject!
func takesUnannotatedParameter(value: AnyObject!)
```

### 轻量级泛型

Objective-C中，使用轻量级泛型进行参数化的声明的`NSArray`，``NSSet`和`NSDictionary`类型，在导入Swift的时候，参数的类型信息会被保留。

例如，下面的这段Objective-C的属性声明：

``` objc
@property NSArray<NSDate *> *dates;
@property NSSet<NSString *> *words;
@property NSDictionary<NSURL *, NSData *> *cachedData;
```

是这样导入Swift的：

``` swift
var dates : [NSDate]
var words : Set<String>
var cachedData : [NSURL : NSData]
```

> **提示**
>
> 除了这些Foundation框架中的集合类之外，Objective-C的轻量级泛型会被Swift忽略。其他任何使用了轻量级泛型的类型在导入Swift的时候，都会被去参数化。

### 扩展

Swift的扩展(Extension)与Objective-C的扩展（Category）类似。*扩展*可以为已有的类、结构体和枚举，甚至是那些在Objective-C中定义的类型，增加新的行为。无论是系统框架中定义的类，还是你自己的自定义类型，你都可以为它们定义扩展。你只需导入适当的模块，用类、结构体或枚举的名字来使用它们，就像在Objective-C中一样。

比如，你可以像下面这样扩展`UIBezierPath`类，利用边长和起始点来创建一个简单的等边三角形贝塞尔曲线。

``` swift
extension UIBezierPath {
	convenience init(triangleSideLength: CGFloat, origin: CGPoint) {
		self.init()
		let squareRoot = CGFloat(sqrt(3.0))
		let altitude = (squareRoot * triangleSideLegth) / 2
		moveToPoint(origin)
		addLineToPoint(CGPoint(x: origin.x + triangleSideLength, y: origin,y))
		addLineToPoint(CGPoint(x: origin.x + triangleSideLength / 2, y: origin.y + altitude))
		closePath()
	}
}
```

你也可以使用扩展增加属性（包括类属性和静态属性）。不过这些属性必须为计算属性；扩展无法为类、结构体或枚举增加带存储的属性。

下面这个扩展的例子展示了如何为`CGRect`结构体增加一个计算属性`area`：

``` swift
extension CGRect {
	var area : CGFloat {
		return width * height
	}
}

let rect = CGRect(x: 0.0, y: 0.0, width: 10.0, height: 50.0)
let area = rect.area
```

你还可以使用扩展来增加协议支持，而无需创建子类。如果协议是在Swift中定义的，那么不管结构体和枚举是在Swift还是在Objective-C中定义的，你都可以通过扩展让它们支持该协议。

你不能使用扩展来覆盖Objective-C类型的已有的方法或属性。

### 闭包

用`@convention(block)`注解标记的Objective-C的块（block）在导入为Swift闭包时，使用Objective-C的调用规则。例如，下面的这个Objective-C的块变量：

``` objc
void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) {
	// ...
}
```

导入Swift后，它是这样的：

``` swift
let completionBlock: (NSData, NSError) -> Void = { (data, error) in
	// ...
}
```

Swift的闭包与Objective-C的块是兼容的，你可以为接受块参数的Objective-C方法传一个Swift的闭包。如果Swift的闭包和函数有相同的类型签名，你甚至可以直接传一个Swift函数名。

闭包与块有着相似的值捕获语义（capture semantics），但是有一个关键的地方不一样：变量是可以被更改的，而不是被复制的。换句话说，Objective-C中，需要使用`__block`标记的变量的行为，在Swift中是默认行为。

#### 捕获self的时候避免强引用循环

在Objective-C中，如果你需要在块中捕获`self`，你需要考量一下内存管理机制。

块会对捕获的对象，包括`self`，保持强引用。如果`self`也对块保持了强引用，比如复制属性，这样就会造成强引用循环。要避免这个问题，你可以让块捕获`self`的一个弱引用：

``` objc
__weak typeof(self) weakSelf = self;
self.block = ^{
	__strong typeof(self) strongSelf = weakSelf;
	[strongSelf doSomething];
}
```

与Objective-C的块一样，Swift也会对捕获的任何对象，包括`self`，保持一个强引用。要避免强引用循环，你需要在闭包的捕获列表中，把`self`标记为`unowned`：

``` swift
self.closure = ^{ [unowned self] in
	self.doSomething()
}
```

要了解更多信息，请参考*Swift编程语言（Swift 2版）*的“解决闭包的强引用循环”章节。

### 对象比较

在比较两个对象的时候，Swift中有两种不同的比较方法。第一种，是*相等*（`==`），比较两个对象的内容。第二种，是*相同（`===`）*，比较常量或变量指向的对象是否为同一个对象实例。

在Swift中，Swift和Objective-C的对象通常使用`==`和`===`操作符进行比较。Swift为派生自`NSObject`类的对象提供了一个默认的`==`操作符实现。这个操作符的视线中，Swift会触发`NSObject`类中定义的的`isEqual:`方法。`NSObject`类只会比较两者是否为同一个对象，因此，如果你的类派生自`NSObject`，你需要实现你自己的`isEqual:`方法。因为你向Objective-C的API传入Swift对象（包括那些不是派生自`NSObject`的对象），因此，如果你希望Swift类在Objective-C的API中也是比较内容，而不是比较是否相同，你也应该为那些类实现`isEqual:`方法。

作为显现类的相等性的一部分，根据对相比较的规则，请确保实现`hash`属性。另外，如果你希望你的类可以用作字典的键，请遵守`Hashable`协议，并实现`hashValue`属性。

### Swift类型的兼容性

当你创建了一个派生自Objective-C类的Swift类，这个类以及它的与Objective-C兼容的成员--属性、方法、下标（subscript，译者注：也就是从一组值中用索引取值的方法）以及构造方法等--会自动对Objective-C可用。在某些情况下，你可能需要精细控制如何将Swift API暴露给Objective-C。如果你的Swift类并不是派生自Objective-C的类，或者你希望修改暴露给Objective-C代码接口的方法名，你可以在Swift类中使用`@objc`注解。如果你使用了类似“键-值观察（key-value observing）”这样动态替换方法实现的的API，你也可以使用`dynamic`修饰符来标记这些通过Objective-C运行时被动态设置的类成员。

#### 在Swift中对Objective-C暴露接口

当你定义了一个派生自`NSObject`或其他Objective-C类的Swift类，这个类会自动与Objective-C兼容。如果你的Swift类并非派生自Objective-C的类，但是你希望你可以在Objective-C代码中访问这个类的API，你可以使用在下面介绍的`@objc`注解。

`@objc`注解使你的Swift API在Objective-C以及Objective-C的运行时环境中可用。换句话说，要在Objective-C代码中使用Swift代码，你要在Swift的方法、属性、下标、构造方法、类、协议、或枚举的前面使用`@objc`注解。

> **提示**
>
> 嵌套的类型定义是不能用`@objc`注解标记的。
>
> 只有使用基本整数类型，如`Int`作为其原始值的Swift枚举，才能使用`@objc`注解。

如果你的类派生自Objective-C类，编译器会自动为你插入注解。编译器也会为标记有`@objc`注解的类的所有成员加上注解。当你使用`@IBOutlet`，`@IBAction`，或`@NSManaged`注解时，也会自动加上`@objc`注解。

需要注意的是，只有派生自`NSObject`的类才能用`@objc`整体标记（编译器会自动标记），但是，如果类并不是派生自`NSObject`，你依然可以用`@objc`标记类内的API。这在调用接受选择器（selector）的Objective-C API，来实现像目标-动作（target-action）设计模式时特别有用，比如`NSTimer`或`UIButton`。

> **提示**
>
> 编译器不会为使用`private`访问级别修饰符的声明自动添加`@objc`注解。

当你在Objective-C中使用Swift API的时候，编译器通常时直接翻译。比如，这个Swift的API `func playSong(name: String)`，导入Objective-C的时候是这样的`- (void)playSong:(NSString *)name`。不过有一个例外：当你在Objective-C中使用Swift的构造函数时，编译器会在方法名前面加上"initWith"，并把第一个参数名首字母大写。例如这个Swift构造器：`init(songName: String, artist: String)`在Objective-C中导入为`- (instanceType)initWithSongName:(NSString *)songName artist:(NSString *)artist`。

Swift还提供了一个`@objc`注解的变体，用来指定暴露给Objective-C的符号名。例如，如果Swift类包含Objective-C不支持的字符，你可以指定一个Objective-C可用的备用名。如果你是为Swift方法指定备用名，请使用Objective-C的选择器语法。记得在选择的各部分之间加上冒号`:`。

``` swift
@objc(Squirrel)
class 松鼠 : NSObject {
	@objc(initWithName:)
	init(名字: String) {
		// ...
	}

	@objc(hideNuts:inTree:)
	func 收藏(几: Int, 个坚果到大树 大树: 树) {
		// ...
	}
}
```

当你对Swift的类使用`@objc(`*name*`)`注解的时候，这个类会在Objective-C中可用，并且不在任何名字空间内。因此，这个注解在你迁移一个可以存档（archivable）的Objective-C类到Swift的时候也很有用。因为可以存档的对象会保存它们的类名到存档文件（archive）中，你应该使用`@objc(`*name*`)`注解来指定与Objective-C类一样的名字，这样，旧的存档文件才能被你的新Swift类解包（unarchive）。

> **提示**
>
> 相对的，Swift也可以用`@nonobjc`注解，让Swift中的声明在Objective-C中不可用。你可以用这个方法来解决桥接方法（bridging methods）的循环引用，这样就可以覆盖用`@objc`注解标记的类中的方法。如果一个Objective-C的方法被Swift的方法覆盖，但该方法无法在Objective-C中表示，例如，通过指定一个参数为变量，拿个方法必须标记为`@nonobjc`。（译者注：__FIXME__此处意思不太明确）

#### 需要动态分配

尽管`@objc`注解能把你的Swift API暴露给Objective-C运行时环境，但是它无法确保属性、方法、下标或构造器的动态分配（dynamic dispatch）。Swift编译器可能依然会去虚化（devirtualize）或内嵌（inline）访问成员，绕过Objective-C环境，优化你的代码的性能。当你用`dynamic`修饰符标记成员的声明，访问这个成员的时候，能保证它总是动态分配的。因为用`dynamic`修饰符标记的声明总是通过Objective-C运行时环境动态分配，它们被隐性地标记了`@objc`注解。

需要动态分配的场景很少。不过如果你知道某个API的实现会被运行时替换，那么你就必须使用`dynamic`修饰符。例如，你可以使用Objective-C运行时环境的`method_exchangeImplementations`方法在程序运行时替换到一个方法的实现。如果Swift编译器内嵌了方法的实现，或者把它的访问去虚化了，那么新的实现将不被使用。

### Objective-C的方法选择器

Objective-C的方法选择器是一种指向Objective-C方法名的类型。在Swift中，Objective-C的方法选择器用`Selector`结构体表示。你可以用一个字符串来构造一个方法选择器，例如`let mySelector: Selector = "tappedButton:"`。因为字符串可以自动转换为方法选择器，所以你可以给所有接受方法选择器参数的方法传入一个字符串。

``` swift
import UIKit

class MyViewController : UIViewController {
	let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))

	override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) {
		super.init(nibName: nibNameOrNil, bundle: nilBundleOrNil)
		myButton.addTarget(self, action: "tappedButton:", forControlEvents: .TouchUpInside)
	}

	func tappedButton(sender:UIButton) {
		print("tapped button")
	}

	required init?(coder:NSCoder) {
		super.init(coder: coder)
	}
}
```

如果你的Swift类继承自Objective-C类，类中的所有的方法和属性都可以用作Objective-C的方法选择器。反之，如果你的Swift类并没有继承自Objective-C类，那么你需要使用`@objc`注解标注你想用作方法选择器的成员，就像在[Swift类型的兼容性](#Swift类型的兼容性)中描述的那样。

#### 用performSelector来发送消息

（译者注：Objective-C的发送消息，在其他语言中叫做方法调用，两者有所区别，但是基本作用相同。）

你可以使用`performSelctor(_:)`及其变体向Objective-C兼容的对象发送消息。

`performSelector` API可以向某个线程或在一段时间的延迟后发送的消息，是没有返回值的。同步执行的`performSelector` API返回一个隐式解包的非托管的可选类型实例（`Unmanaged<AnyObject>!`），因为执行方法选择器得到返回值的类型、所属关系在编译时无法知晓。你可以阅读[非托管对象](#非托管对象)章节了解更多信息。

``` swift
let string: NSString = "Hello, Cocoa!"
let selector: Selector = "lowercaseString"
if let result = string.performSelector(selector) {
	print(result.takeUnretainedValue())
}
// 打印出 "hello, cocoa!"
```

向对象发送一个无法识别的方法选择器，会导致接收者去调用`doesNotRecognizeSelector(_:)`，这个方法默认引发一个`NSInvalidArgumentException`异常。

``` swift
let array: NSArray = ["delta", "alpha", "zulu"]
let invalidSelecto: Selector = "invalid"
array.performSelector(invalidSelector) // 引发一个异常
```

在Objective-C运行时向对象直接发送消息在本质上是不安全的，因为编译器无法对发送消息得到的结果作保证，甚至无法保证对象可以接收某个消息。因此，通常是不鼓励使用`performSelector` API的，除非你的代码对Objective-C运行时提供的动态方法解析有特殊需求。否则，把一个类型的对象转换成`AnyObject`，然后使用可选调用链来调用方法会安全很多。详见[id的兼容性](#id的兼容性)。

编写具备Objective-C行为的Swift类
------------------------------

互操作性是你能够定义具备Objective-C行为的Swift类。你可以在编写Swift类的时候继承Objective-C的类，接受Objective-C的协议，并利用其他Objective-C的功能。这意味着你可以创建基于你熟悉的、有着明确Objective-C行为的类创建子类，同时，你可以使用Swift的现代、强大的语言特征来增强它。

### 继承Objective-C的类

在Swift中，你可以定义Objective-C类的子类。要创建一个继承自Objective-C类的Swift类，你可以在Swift的类名后架上冒号（`:`），再加上Objective-C类的名字。

``` swift
import UIKit
class MySwiftViewController : UIViewController {
	// 定义这个类
}
```

你可以获得用Objective-C定义的超类的所有功能。如果你要为超类中的同名方法提供你自己的实现，你需要使用`override`关键字。

#### NSCoding

`NSCoding`协议要求符合改协议的类型实现`init(coder:)`构造方法。直接接受`NSCoding`协议的类必须实现这个方法，该类的子类如果有一个以上自定义构造方法、或包含没有初始值的属性，那么它也必须接受`NSCoding`协议。Xcode提供了下面这个自动修正（fix-it）功能，提供了一个默认实现：

``` swift
required init(coder aDecoder: NSCoder) {
	fatalError("init(coder:) has not been implemented")
}
```

对于从StoryBoard中加载的对象，或者用`NSUserDefaults`或`NSKeyedArchiver`从磁盘上解包的对象，你必须为这个构造函数提供一个完整的实现。不过，你可能不需要为那些无法或不会通过这种途径初始化的类型实现这个构造方法。

### 支持协议

Objective-C的协议会导入为Swift的协议，类可以通过在其父类名后，加上逗号分割的协议名列表，来支持协议，如果需要的话。

``` swift
class MySwiftViewController : UIViewController, UITableViewDelegate, UITableViewDataSource {
	// 定义这个类
}
```

在Swift代码中，要定义一个符合单个协议的类型，可以直接使用协议名作为其类型（对比Objective-C中的`id<SomeProtocal>`）。要在Swift代码中定义一个符合多个协议的类型，可以使用复合协议（protocal composition），形如`protocal<SomeProtocal, AnotherProtocal>`（对比Objective-C中的`id<SomeProtocal, AnotherProtocal>`）。

``` swift
var textFieldDelegate: UITableViewDelegate
var tableViewController: protocal<UITableViewDataSource, UITableViewDelegate>
```

> **提示**
>
> 因为Swift中的类和协议使用同一个名字空间，因此，Objective-C中的`NSObject`协议在Swift中被映射为`NSObjectProtocal`。

### 编写构造方法和析构方法

Swift的编译器会确保你的构造方法不会遗留任何没有初始化的属性以增强代码的安全性和可预测性。另外，与Objective-C不同的是，Swift不需要额外调用内存分配方法。即便你在使用Objective-C的类，你也只需要使用原生的Swift构造语法--Swift会把Objective-C的构造方法转换成Swift的构造方法。你可以阅读**构造方法**章节，了解更多关于如何实现你自己的构造方法的信息。

当你需要在对象被回收时，作一些额外的清理工作，你可以实现一个析构方法，而不是使用`dealloc`方法。Swift的析构方法会在实例被回收前自动调用。Swift会在触发字类的析构方法后，自动调用父类的析构方法。当你使用Objective-C类，或者你的Swift类继承自Objective-C类，Swift一样也会调用该类的父类的`dealloc`方法。你可以阅读*Swift编程语言（Swift 2版）*的**析构方法**章节了解更多关于如何实现你自己的析构方法的信息。

### 在Objective-C API中使用Swift的类名

Swift的类是基于它们编译进的模块来确定名字空间的，即便是用于Objective-C的代码中时也一样。和所有的类都在全局名字空间中，从而不能包含两个同名类的Objective-C不一样，Swift的类可以通过它们所处的模块进行区分。例如，在名为`MyFramework`的框架中，名为`DataManager`的类的全名`MyFramework.DataManager`。Swift应用的编译目标（Target）也是一个模块，因此在一个叫做`MyGreatApp`的应用中，名为`Observer`的类的全名为`MyGreatApp.Observer`。

为了保留在Objective-C中使用的Swift类的名字空间，Swift的类暴露给Objective-C运行时环境的时候，暴露的是全名。因此，当你使用以字符串的形式操作Swift的类名的时候，你必须使用类的全名。例如，当你需要创建一个基于文档的Mac应用的时候，你需要在应用的`Info.plist`文件中指定`NSDocument`子类的类名。如果你是用Swift编写应用，那么你必须使用这个文档子类的全名，也就是要包含了基于应用或框架的模块名。

在下面这个示例中，`NSClassFromString`函数用来通过字符串形式的类名来获取类的引用。要获取一个Swift类，你就必须使用包含了应用名的类的全名：

``` swift
let myPersonClass: AnyClass? = NSClassFromString("MyGreatApp.Person")
```

### 与Interface Builder整合

（译者注：Interface Builder作为一个Xcode的一个组件，我没有给出翻译。一方面翻译后听起来很别扭；另一方面，也不方便用户对照查找。Interface Builder字面上的意思“界面构建器”。）

Swift编译器包含了能让你的Swift类与Interface Builder交互的注解。和在Objective-C中一样，你可以使用外连（outlets），动作（actions）和实时渲染。

（译者注：outlet在业界还没有统一的翻译，这里暂时翻译成外连。后文中可能会根据情况，保留英文原文。）

#### 使用外连和动作

外连和动作能把你的源代码和Interface Builder中的用户界面对象连接起来。要在Swift中使用外连和动作，你可以在属性和方法声明的前面分别加上`@IBOutlet`和`@IBAction`注解。`@IBOutlet`也可以用来声明外连集合（outlet collection）--只需指定类型为数组。

当你在Swift中声明外连的时候，你需要把类型设置为隐式解包可选类型（implicit unwrapped optional）。这样，storyboard就能在初始化之后，通过运行时把外连和界面连接起来了。当你的类通过storyboard或xib文件初始化完成后，你就可以认为外连已经连接好了。

例如，下面这段Swift代码定义了一个包含有一个外连，一个外连集合和一个动作的类：

``` swift
class MyViewController : UIViewController {
	@IBOutlet weak var button: UIButton!
	@IBOutlet var textFields: [UITextField]!
	@IBAction func buttonTapped(_: AnyObject) {
		print("button tapped!")
	}
}
```

因为`sender`参数在`buttonTapped`方法中没有用到，因此参数名可以忽略。

#### 实时渲染

你可以使用另外两个注解--`@IBDesignable`和`@IBInspectable`--来使用实时渲染，在Interface Builder中与自定义视图（View）进行交互。当你创建了一个派生自`UIView`或`NSView`类的自定义视图的时候，你就可以在类声明的前面加上`@IBDesignable`注解。当你把这个自定义视图加入Interface Builder中之后（通过在inspector面板中，设置视图对应的自定义类），Interface Builder就会在画板（Canvas）上对你的视图进行实时渲染。

你还可以对支持自定义的类型的属性使用`@IBInspectable`注解。在你把自定义视图加入Interface Builder中之后，你就能在inspector面板中编辑这些属性了。

``` swift
@IBDesignable
class MyCustomView: UIView {
	@IBInspectable var textColor: UIColor
	@IBInspectable iconHeight: CGFloat
	// ...
}
```

### 指定属性的注解

（译者注：这里把描述属性的参数也一并翻译为注解。注意区别于Java中的注解概念，两者有相似点，但是并不是同一概念。）

在Objective-C中，属性有一系列可以指定关于属性行为的额外信息的注解。在Swift中，你用不同的方式来指定这些属性注解。

#### 强引用和弱引用

Swift的属性默认是强引用。你需要使用`weak`关键词来表明属性指向的存储属性值的对象使用的是弱引用。这个关键词只能被用于可选类型的属性。详情请参阅*Swift编程语言（Swift 2版）*的“参数（Attributes）”章节。

#### 读写与只读

在Swift中，没有`readwrite`和`readonly`注解。当声明存储属性时，使用`let`来使之成为只读，使用`var`来使之可以读写。当声明计算属性的时候，只提供取值方法（getter）使之成为只读，同时提供取值方法（getter）和赋值方法（setter）使之可以读写。要了解更多信息，请查看*Swift编程语言（Swift 2版）*。

#### 复制语义

在Swift中，Objective-C的`copy`属性注解被转译为`@NSCopying`。属性的类型需要复合`NSCopying`协议。要了解更多信息，请查看*Swift编程语言（Swift 2版）*的“参数（Attributes）”章节。

### 实现Core Data的托管对象子类

（译者注：这里Managed Object翻译成托管对象。如果你学过.NET，请不要把这里的托管对象与.NET里的托管对象混淆，两者概念不一样。）

Core Data为`NSManagedObject`的子类提供了属性的底层存储和实现的支持。Core Data还提供了从对多关系（to-many relationship）增加和删除对象的实例方法的实现。你可以使用`@NSManaged`注解来告诉Swift编译器，Core Data会在运行时提供存储和实现。

你需要在你的托管类的子类中，为所有与Core Data模型相关的属性和关系有关的属性和方法声明加上`@NSManaged`注解。比如，假设有一个名为“Person”的Core Data实体（Entity）有一个字符串属性“name”，以及一个对多的关系“friends”：

![img](./pics/pic_2.1.png)

以下是`NSManagedObject`子类的`Person`对应的Swift代码：

``` swift
import CoreData
class Person : NSManagedObject {
	@NSManaged var name: String
	@NSManaged var friends: NSSet

	@NSManaged func addFriendsObject(friend: Person)
	@NSManaged func removeFriendsObject(friend: Person)
	@NSManaged func addFriends(friends: NSSet)
	@NSManaged func addFriends(friends: NSSet)
}
```

`name`和`friends`属性声明都使用了`@NSManaged`注解，用来指示Core Data在运行时为它们提供了存储和实现。因为`friends`属性是对多关系，Core Data还提供了一系列对应的访问方法实现。

要把用Swift编写的`NSManagedObject`子类用于Core Data的模型实体，你需要打开Xcode的模型实体检查面板，在Class文本框中输入类名，并从Module下拉列表中选择“Current Product Module”。

![img](./pics/pic_2.2.png)

使用Cocoa数据类型
----------------

作为与Objective-C互操作性功能的一部分，Swift提供了便利而高效的使用Cocoa数据类型的方法。

Swift会自动把部分Objective-C的数据类型转换成Swift的数据类型，和部分Swift数据类型转换成Objective-C数据类型。有一部分数据类型在Swift和Objective-C中时可以通用的。可以转换或通用的数据类型，我们称之为*桥接*（bridged）类型例如，在Swift代码中，你可以把`Array`类型的值传给一个接受`NSArray`对象的方法。你也可以在桥接的类型之间进行类型转换。当你使用`as`或直接显式地指定常量或变量的类型在桥接的类型之间进行转换时，Swift会自动对类型进行桥接。

Swift还为Foundation数据类型提供了快捷接口层，让这些数据类型的使用语法，感觉起来与Swift语言的其它部分更佳自然、一致的结合。

### 字符串

Swift会自动桥接`String`类型和`NSString`类。这意味着如果你在任何地方需要使用`NSString`，那么你也可以使用`String`类型替代，并且同时具有`String`类型的字符串变量插入（interpolation）功能和其它的Swift字符串API，以及`NS String`类提供的大量功能。因此，你几乎永远都不需要在你的Swift代码中直接使用`NSString`类。事实上，在Swift导入Objective-C的API时，会把所有的`NSString`类型替换为`String`类型。当你的Objective-C代码导入Swift类的时候，在导入的API中，所有的`String`类型都会被替换为`NSString`类型。

要使用字符串桥接，你只需要导入Foundation模块。比如，你可以对Swift字符串访问`NSString`类的属性--`capitalizedString`，Swift会自动桥接`String`到`NSString`对象以访问这个属性。这个属性甚至会直接返回Swift的`String`类，因为它在导入的过程中已经进行了类型转换。

``` swift
import Foundation
let greeting = "hello, world!"
let capitalizedGreeting = greeting.capitalizedString
// capitalizedString: String = Hello, World!
```

如果你确实需要使用`NSString`对象，你可以在需要的时候通过类型转换把它转成Swift的`String`类型值。因为`String`类型值随时都可以由`NSString`对象转换而成，因此在进行类型转换时无需使用可选类型转换操作符（`as?`）。你也可以通过为变量或常量显式地指定类型来用字符串字面量（string literal）创建一个`NSString`对象。

``` swift
import Foundation
let myString : NSString = "123"
if let integerValue = Int(myString as String) {
	print("\(myString) is the integer \(integerValue)")
}
// 打印出"123 is the integer 123"
```

> **提示**
>
> Swift的`String`结构体类型的实例无法用`AnyObject`类型来表示，因为`AnyObject`只能用来代表类的实例。不过，当Foundation的桥接启用后，Swift的`String`值会被桥接到`NSString`类的实例，这样就可以被赋值给`AnyObject`类型的常量或变量了。

#### 本地化

在Objective-C中，通常使用`NSLocalizedString`系列的宏定义来创建本地化字符串的。这个系列的宏包括`NSLocalizedString`，`NSLicalizedStringFromTable`，`NSLocalizedStringFromTableInBundle`和`NSLocalizedStringWithDefaultValue`。在Swift中，你可以使用一个方法--`NSLocalizedString(key:tableName:bundle:value:comment:)`--来提供整个`NSLocalizedString`系列的宏的功能。`NSLocalizedString`为`tableName`，`bundle`和`value`参数提供了默认值。你可以在以前使用宏的地方使用这个方法。

### 数字类型

Swift会自动桥接原生的数字类型，例如`Int`和`Float`到`NSNumber`类型。这个桥接功能让你可以用这些类型创建`NSNumber`对象：

``` swift
let n = 42
let m : NSNumber = n
```

这也允许你把`Int`类型值传给接受`NSNumber`对象作为参数的方法。需要注意的是，因为`NSNUmber`能够包含多种数字类型的对象，所以你不能把它传给接受某种特定的数字类型，比如`Int`值的方法。

以下所有的类型都会自动桥接到`NSNumber`：

- `Int`
- `UInt`
- `Float`
- `Double`
- `Bool`

> **提示**
>
> Swift的数字结构体类型，比如`Int`，`UInt`，`Float`，`Double`和`Bool`的实例无法用`AnyObject`类型来表示，因为`AnyObject`只能用来代表类的实例。不过，当Foundation的桥接启用后，Swift的数字类型值会被桥接到`NSNumber`类的实例，这样就可以被赋值给`AnyObject`类型的常量或变量了。

### 集合类

Swift会分别把`NSArray`，`NSSet`和`NSDictionary`桥接到`Array`，`Set`和`Dictionary`类。这意味着你可以在利用Swift强大的算法的同时，用自然的语法来操作集合类，并能同时使用Foundation和Swift的集合类型。

#### 数组

Swift自动桥接`Array`和`NSArray`类。当你把参数化的`NSArray`对象桥接到Swift数组的时候，得到的数组的类型是`[ObjectType]`。如果`NSArray`对象没有参数化类型，它会桥接到类型为`[AnyObject]`的Swift数组。

例如下面的这段Objective-C声明：

``` objc
@property NSArray<NSDate *> *dates;
- (NSArray<NSDate *> *)datesBeforeDate:(NSDate *)date;
- (void)addDatesParsedFromTimestamps:(NSArray<String *> *)timestamps;
```

Swift导入后会是下面这样：

``` swift
var dates : [NSDate]
func datesBeforeDate(date: NSDate) -> [NSDate]
func addDatesParsedFromTimestamps(timestamps: [String])
```

如果一个对象是Objective-C或Swift类的实例，或者可以被桥接到一个类，那么它就与`AnyObject`兼容。你可以桥接所有的`NSArray`对象到Swift的数组，因为所有的Objective-C对象都与`AnyObject`兼容。因为所有的`NSArray`对象都可以桥接到Swift的数组，所以Swift编译器在导入Objective-C的API时会把`NSArray`类替换为`[AnyObject]`。

在你把`NSArray`对象桥接到Swift数组之后，你就可以把数组的类型转换成更加明确的类型。与把`NSArray`对象转换成`[AnyObject]`类型不同的是，把`AnyObject`向下转换成一个更加明确的类型并不能保证成功。在运行之前，编译器是无法确知数组的所有元素都能被转换成你所指定的类型的。因此，你需要使用条件类型转换操作符`as?`来将`[AnyObject]`向下转换为`[SomeType]`，在你确信转换可以成功时，也可以使用无条件类型转换操作符`as!`。例如，如果你知道Swift数组只包含`NSView`类（或`NSView`的子类）的实例，你就可以把包含`AnyObject`类型元素的数组向下转换成`NSView`对象数组了。如果在运行时，Swift数组中有任何一个元素不是`NSView`对象，类型转换的结果就回返回`nil`。

``` swift
let swiftArray = fundationArray as [AnyObject]
if let downcastedArray = swiftArray as? [NSView] {
	// downcastedArray只含有NSView对象的话，会执行到这里
}
```

你也可以直接在for循环中，把`NSArray`对象转换成特定类型的Swift数组：

``` swift
for view in foundationArray as! [NSView] {
	// view的类型为NSView
}
```

当你把Swift的数组桥接到`NSArray`对象时，Swift数组的所有成员必须与`AnyObject`兼容。例如，一个类型为`[Int]`的Swift数组包含的时`Int`结构体元素。虽然`Int`类型并不是一个类的实例，但是`Int`类型可以被桥接至`NSNumber`类，因此`Int`类型依然与`AnyObject`兼容的。所以你可以把类型为`[Int]`的Swift数组桥接到`NSArray`对象。如果Swift数组的元素类型和`AnyObject`不兼容，那么当你把它桥接到`NSArray`对象时，会引起一个运行时错误。

> **提示**
>
> 作为性能优化的一项措施，把一个集合无条件向下类型转换成另一个类型更加特殊的集合时，例如，`NSArray as! [String]`，数组成员的类型检查可能会被延迟到它们被访问的时候才会进行。因此，无条件类型转换为不兼容的类型可能会看起来成功了，直到元素的类型转换失败触发一个运行时错误。
>
> 把一个集合对象通过条件类型转换转成另一个类型更加特殊的集合时，例如，`NSArray as? [String]`，会立刻对所有的数组元素进行类型检查。如果有任何数组元素在进行类型转换时出错，就回返回`nil`。

你也可以通过与前面提到的桥接规则相同的方式，直接用Swift的数组字面量创建一个`NSArray`对象。当你显式地把一个常量或变量指定为`NSArray`类型，并给它赋值一个数组字面量时，Swift会创建一个`NSArray`对象而不是Swift数组。

``` swift
let schoolSupplies : NSArray = ["Pencil", "Eraser", "Notebook"]
// schoolSupplies是一个包含NSString对象的NSArray对象。
```

上例中，Swift的数组字面量包含了三个`String`字面量。因为`String`类型可以桥接至`NSString`类，所以数组字面量会被桥接至`NSArray`对象，对`schoolSupplies`的赋值就成功了。

当你在Objective-C代码中使用Swift类或协议的时候，所有的Swift数组都会在导入的API中被替换为`NSArray`。如果你把一个`NSArray`对象传给一个接受不同类型元素的数组的Swift API时，就会引发一个运行时错误。如果Swift API返回的Swift数组不能被桥接至`NSArray`，也会引发运行时错误。

#### 数集

（译者注：Set通常会翻译为集合，但是这样翻译可能会和Collection(集合)混淆，因此我这里把Set翻译为数集。在程序语言中的数集的成员并不局限于数字，通常可以包含任何对象，与数组(array)类似的，请不要因为Set的翻译中包含“数”这个字而引起误会。）

除了数组之外，Swift会自动把`Set`类型桥接为`NSSet`类。当你把参数化的`NSSet`对象桥接至Swift数集时，得到的数集对象的类型为`Set<ObjectType>`。如果`NSSet`对象没有参数化，它会被桥接到类型为`Set<NSObject>`（译者按：因为数集实际上声明为`Set<Element : Hashable>`，因为有了`Hashable`这个约束，所以映射的时候不是`AnyObject`，而是`NSObject`，这一点区别于数组。另外，此处与后文中有出入，但是译者认为，即便后文使用了`Set<AnyObject>`这种表示方式，这里的`AnyObject`也需要遵守`Hashable`协议）的Swift数集。

例如，下面这段Objective-C声明：

``` objc
@property NSSet<NSStirng *> *words;
- (NSSet<NSString *> *)wordsMatchingPredicate:(NSPredicate *)predicate;
- (void)removeWords:(NSSet<NSString *> *)words;
```

导入Swift之后是这样的：

``` swift
var words: Set<String>
func wordsMatchingPredicate(predicate: NSPredicate) -> Set<String>
func removeWords(words: Set<String>)
```

你可以把任意`NSSet`对象桥接至Swift数集，因为所有的Objective-C对象都可以被桥接至`AnyObject`。因为所有的`NSSet`对象都可以桥接至Swift数集，因此Swift编译器在导入Objective-C API的时候，会把`NSSet`类替换为`Set<AnyObject>`。类似的，当你在Objective-C代码中使用Swift类或协议的时候，Swift的数集对象会被重映射至`NSSet`对象。

把`NSSet`对象桥接至Swift数集的之后，你可以把这个集合向下类型转换为一个更特殊的数集类型。和Swift数组的向下类型转换一样，Swift数集的向下类型转换并不保证成功，使用`as?`操作符把`Set<AnyObject>`向下转换为更特殊的类型时，会返回一个可选类型值。

你也可以通过与前面提到的桥接规则相同的方式，用一个Swift数组字面量创建一个`NSSet`对象，当你显式地把一个常量或变量指定为`NSSet`类型，并给它赋值一个数组字面量时，Swift会创建一个`NSSet`对象而不是Swift数集。

#### 字典

Swift也会自动桥接`Dictionary`类型和`NSDictionary`类。当你把参数化的`NSDictionary`对象转换成一个Swift字典时，得到的字典的类型是`[ObjectType: AnyObject]`（译者按，原文为`[ObjectType]`，应该是错误的。）。如果`NSDictionary`对象没有参数化，那么它会被桥接至类型为`[NSObject: AnyObject]`的Swift字典类型。

例如，下面这段Objective-C声明：

``` objc
@property NSDictionary<NSURL *, NSData *> *cachedData;
- (NSDictionary<NSURL *, NSNumber *> *)fileSizesForURLsWithSuffix:(NSString *)suffix;
- (void)setCacheExpirations:(NSDictionary<NSURL *, NSDate *>)expirations;
```

导入Swift之后是这样的：

``` swift
var cachedData: [NSURL: NSData]
func fileSizesForURLsWithSuffix(suffix: String) -> [NSURL: NSNumber]
func setCacheExpirations(expirations: [NSURL: NSDate])
```
你可以把人和`NSDictionary`对象桥接到Swift字典，因为所有的Objective-C对象都与`AnyObject`兼容。回忆一下，如果对象是Objective-C或Swift的类的实例，或可以被桥接到一个类，那么它就与`AnyObject`兼容。因为所有的`NSDictionary`对象可以被桥接到Swift字典，所以Swift编译器会在导入Objective-C API的时候把`NSDictionary`类替换为`[NSObject: AnyObject]`。类似的，当你在Objecitve-C代码中使用Swift的类或协议时，Swift字典会被重映射为`NSDictionary`对象。

把`NSDictionary`对象桥接至Swift字典的之后，你可以把这个集合向下类型转换为一个更特殊的字典类型。和Swift数组和数集的向下类型转换一样，Swift字典的向下类型转换并不保证成功，使用`as?`操作符把`[NSObject: AnyObject]`向下转换为更特殊的类型时，会返回一个可选类型值。

当你反向类型转换的时候--从Swift字典转换成`NSDictionary`对象--键和值必须都是类的实例，或者可以被桥接到某个类的实例。

你也可以通过与前面提到的桥接规则相同的方式，用一个Swift字典字面量创建一个`NSDictionary`对象，当你显式地把一个常量或变量指定为`NSDictionary`类型，并给它赋值一个字典字面量时，Swift会创建一个`NSDictionary`对象而不是Swift字典。

### 错误

Swift自动把`ErrorType`桥接至`NSError`类。会发生错误的Objective-C方法，会被导入为可抛出异常的Swift方法，而能抛出异常的Swift方法，会遵循Objective-C的错误处理惯例，被导入为会发生错误的Objective-C方法。

有`@objc`注解，并符合`ErrorType`协议的Swift枚举类型，会在生成的头文件中创建一个`NS_ENUM`声明以及错误领域（error domain）所对应的字符串常量。例如，下面这个Swift枚举类型声明：

``` swift
@objc public enum CustomError: Int, ErrorType {
	case A, B, C
}
```

在生成的头文件中会生成下述对应的Objective-C声明：

``` objc
// Project-Swift.h
typedef Swift_ENUM(NSInteger, CustomError) {
	CustomErrorA = 0,
	CustomErrorB = 1,
	CustomErrorC = 2,
};
static NSString * const CustomErrorDomain = @"Project.CustomError";
```

请参阅[错误处理](#错误处理)章节了解更多关于如何在Swift和Objective-C API中使用错误处理的信息。

### Foundation数据类型

Swift为在Foundation框架中定义的数据类型提供了一个快捷的封装接口。用这个封装层来操作`CGSize`和`CGPoint`的时候，语法感觉起来更加自然，与其它Swift代码更加一致。比如，你可以使用这种语法来创建`CGSize`结构体：

``` swift
let size = CGSize(width: 20, height: 40)
```

你也可以通过这个封装层自然地调用Foundation的函数和结构体。

``` swift
let rect = CGRect(x: 50, y: 50, width: 100, height: 100)
let width = rect.width  // 等价于 CGRectGetWidth(rect)
let maxY = rect.maxY    // 等价与 CGRectGetMaxY(rect)
```

Swift会把`NSUInteger`和`NSInteger`桥接至`Int`。在Foudation API中，这两种类型都被导入为`Int`。在Swift中，在所有可能的时候都会使用`Int`以保持一致性，不过`UInt`类型在某些一定要使用无符号整数类型的地方还是可用的。

### Foundation函数

`NSLog`在Swift中还是可以用来向控制台输出日志。你可以使用于Objective-C一样的语法来调用它。

``` swift
NSLog("%.7f", pi)
// 把 "3.1415927" 输出到控制台
```

Swift自身也提供了一个打印函数`print(_:)`。这个函数支持Swift的字符串插入，所有用起来简单、强大而且通用。这个函数不会输出到系统控制台，但是可以满足常规的打印需求。

`NSAssert`系列函数没有被引入Swift。取而代之的是`assert`函数。

### Core Foundation

Core Foundation类型会自动被导入为功能完备的Swift类。只要包含了内存管理的注解，Swift会自动管理Core Foundation对象的内存，包括你在代码中创建的Core Foundation对象。在Swift中，你可以互换使用Foundation和Core Foundation的无缝桥接(toll-free bridge)类型对。部分无缝桥接的Core Foundation类型，如果你先把它转换成Foundation类型，那么你还可以把它映射到Swift标准库中的类型。

#### 重映射的类型

当Swift导入Core Foundation类型时，编译器会对类型名进行重映射。编译器把*Ref*从名字的末尾去除了，因为所有的Swift类都是引用类型，因此这个词尾是多余的。

Core Foundation的`CFTypeRef`类型则完全被重映射为`AnyObject`类型。在你的代码中，所有以前使用`CFTypeRef`的地方，现在都要使用`AnyObject`。

#### 受内存管理的对象

从包含内存管理注解的API中返回的Core Foundation对象，Swift会自动对它们进行内存管理--你不需要自己手动调用`CFRetain`，`CFRelease`或`CFAutoRelease`函数。

如果你需要从你自己的C函数或Objective-C方法中返回Core Foundation对象，那么你就需要为它们添加`CF_RETURN_RETAINED`或`CF_RETURN_NOT_RETAINED`宏作为注解，以自动插入内存管理调用。你也可以根据Core Foundation的所属关系（ownership）策略，使用`CF_IMPLICIT_BRIDGING_ENABLED`和`CF_IMPLICIT_BRIDGING_DISABLED`宏来包围C函数声明，以通过命名方式来暗示内存管理机制。

如果你只需要用到包含了内存管理注解，且不会间接返回Core Foundation对象的API的话，你可以跳过本节的其它部分。否则请继续阅读关于如何操作不受内存管理对象的内容。

#### 不受管理的对象

当Swift导入不包含内存管理注解的API时，编译器无法对返回的Core Foundation对象进行自动内存管理。Swift会把这些返回的Core Foundation对象封装进`Unmanaged<Instance>`结构体中。所有间接返回的Core Foundation对象也是不受内存管理的。比如，下面这个未注解的C函数：

``` c
CFStringRef StringByAddingTwoString(CFStringRef s1, CFStringRef s2)
```

Swift会这样导入它：

``` swift
func StringByAddingTwoString(_:CFString!, _:CFString!) -> Unmanaged<CFString>! {
	// ...
}
```

当你从一个无注解的API接收到一个不受内存管理的对象时，在操作它之前，你应该马上把它转换成一个受内存管理的对象。这样，Swift帮你进行内存管理。`Unmanaged<Instance>`结构体提供了两个把不受内存管理的对象转换成受内存管理的对象的方法--`takeUnretainedValue()`和`takeRetainedValue()`。这两个方法都会返回原始的、解包过的类型的对象。你需要根据调用的API返回的对象是否为保留（retain）过，来选择使用哪个方法。

例如，假设上述C函数在返回之前没有保留（retain）过`CFString`对象。那么在操作这个对象之前，你需要使用`takeUnretainedValue()`方法。

``` swift
let memoryManagedResult = StringByAddingTwoStrings(str1, str2).takeUnretainedValue()
// memoryManagedResult 是一个受内存管理的CFString对象。
```

你也可以对不受内存管理的对象调用`retain()`，`release()`和`autorelease()`方法，不过这种方式不受推荐。

要了解更多信息，请参阅*Memory Management Programming Guide for Core Foundation*文档。

使用Cocoa设计模式
----------------
